## 操作系统基础问答

### 1. 操作系统组成

- 进程管理

- 存储管理

- 设备管理

- 文件管理

- 程序接口

- 用户界面 

### 2. 进程与线程的区别

| 进程                                                         | 线程                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 进程是操作系统资源分配的基本单位                             | 线程是任务调度和执行的基本单位                               |
| 每个进程都有独立的代码和数据空间（程序上下文），进程之间的切换会有较大的开销 | 线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小 |
| 在操作系统中能同时运行多个进程（程序）                       | 在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行） |
| 系统在运行的时候会为每个进程分配不同的内存空间               | 对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源 |
| 没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的 | 线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程   |

### 3. 线程同步方法

（1）临界区：用于进程内部的线程同步，通过对多线程串行化访问公共资源来保证在某一时刻只有一个线程能访问数据

（2）信号量：允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数，信号量最大资源数为1时就是互斥量

（3）互斥量：只有拥有互斥对象的线程才能访问公共资源，由于互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问

（4）事件：来通知线程有一些事件已发生，从而启动后继任务的开始

##### Java线程同步方法

可以使用synchronized、lock、volatile和ThreadLocal来实现同步。**synchronized块获得的是一个对象锁，换句话说，synchronized块锁定的是整个对象。**

### 4. 进程间通信的方式，哪种最快

**管道**：非命名管道只能用于父子进程通讯，是一种半双工的通信方式，数据只能单向流动，传输的是无格式的流。管道它就像一个特殊的文件，但这个文件只存在于内存中，在创建管道时，系统为管道分配了一个页面作为数据缓冲区，进程对这个数据缓冲区进行读写，以此来完成通信。其中一个进程只能读一个只能写，所以叫半双工通信，为什么一个只能读一个只能写呢?因为写进程是在缓冲区的末尾写入，读进程是在缓冲区的头部读取，他们各自的数据结构不同，所以功能不同。

**消息队列**：用于两个进程之间的通讯，首先在一个进程中创建一个消息队列，然后再往消息队列中写数据，而另一个进程则从那个消息队列中取数据。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点

**信号量**：不能传递复杂消息，只能用来同步，用来控制多个进程对共享资源的访问。临界资源：为某一时刻只能由一个进程或线程操作的资源，当信号量的值大于或等于0时，表示可以供并发进程访问的临界资源数，当小于0时，表示正在等待使用临界资源的进程数。更重要的是，信号量的值仅能由PV操作来改变。

**信号**: 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。主要作为进程间以及同一进程不同线程之间的同步手段。

**共享内存**：只要首先创建一个共享内存区，其它进程按照一定的步骤就能访问到这个共享内存区中的数据，当然可读可写；【速度快】

**套接字(socket)**: 用于不同主机间的进程通信。

管道、消息队列和socket发送和接收数据的时候得系统调用，而共享内存只有创建的时候需要系统调用，发送和接收数据则不需要系统调用，因此时间花费相对少。

### 5. 信号量怎么实现对共享资源的访问

1. 信号灯: S为信号量的值：S>0表示可用资源的数量；S<0表示该信号量队列上排队的进程控制块(PCB)数

2. P、V操作: P：减1操作，结果大于等于0继续执行；V：加1操作，结果大于0继续执行

### 6. 操作系统为什么分用户态和内核态

在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级——用户态和内核态。 

| 内核态                               | 用户态                                               |
| ------------------------------------ | ---------------------------------------------------- |
| 操作系统管理程序执行时机器所处的状态 | 用户程序执行时机器所属的状态                         |
| 允许使用全部系统资源和全部指令       | 禁止使用特权指令，不能直接取用系统资源和改变机器状态 |
| 允许访问整个存储区                   | 只允许用户程序访问自己的存储区域                     |

进一步可把管态细分为管态和核态，此时管态只允许使用一些在用户态下所不能使用的资源，但不能使用修改机器状态的指令。

### 7. 用户级线程与内核级线程如何转换

用户态切换到内核态的3种方式：

- **系统调用**：这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。
- **中断**：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
- **异常**: 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

### 8. 计算机是64位的，那么里面有什么跟64相关

- 64位指的是机器字长。计算机CPU内部的操作字长度为64位，能一次处理64位数据

- 数据总线一次能传送64位数据

### 9. 虚拟内存

计算机系统在处理应用程序时，只装入部分程序代码和数据就启动其运行，由操作系统和硬件相配合完成主存和外围联机存储器之间的信息的动态调度，这样计算机系统好像为用户提供了一个其存储容量比实际主存大得多的存储器，使应用程序以为它拥有连续的可用内存，**<u>通过内存地址转换解决了多个进程访问内存冲突的问题</u>**， 这个存储器称为虚拟存储器。但是在执行指令的时候，必须先把逻辑地址转化为物理地址。

虚拟内存抽象了应用程序物理内存的细节，只允许物理内存保存所需的信息（按需分页），并提供了一种保护和控制进程间数据共享数据的机制。有了虚拟内存机制之后，每次访问可以使用更易理解的虚拟地址，让CPU转换成实际的物理地址访问内存，降低了直接使用、管理物理内存的门槛。

物理内存按大小被分成页框、页，每块物理内存可以被映射为一个或多个虚拟内存页。这块映射关系，由操作系统的页表来保存，页表是有层级的。层级最低的页表，保存实际页面的物理地址，较高层级的页表包含指向低层级页表的物理地址，指向顶级的页表的地址，驻留在寄存器中。当执行地址转换时，先从寄存器获取顶级页表地址，然后依次索引，找到具体页面的物理地址。

### 10. 页式存储、段式存储、段页式存储

1. 页式存储：程序的地址空间被分成大小相等的块（虚页），主存被分成大小相等的片（实页）——一维地址表

2. 段式存储：分段是程序中自然划分的一组逻辑意义完整的信息集合（代码分段、数据分段、堆栈段）——二维地址表

3. 段页式存储：整体分段，段内分页地址（段号+段内页号+页内位移）

| 分页                                 | 分段                                 |
| ------------------------------------ | ------------------------------------ |
| 可实现存储空间的物理划分             | 程序地址空间的逻辑划分               |
| 页面大小固定且相等                   | 分段程度可变且不相等                 |
| 用户不可见                           | 用户可见                             |
| 程序地址分成页号和页内位移是硬件功能 | 程序地址分成段号和段内位移是逻辑功能 |

### 11. 页置换算法 

1. **最优页面置换算法**：选择最长时间未被使用的一页淘汰，但由于无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。最优置换算法可以用来评价其他算法。

2. **先进先出算法**：总是选择在主存中驻留时间最长的一页淘汰

3. **最近最少算法（LRU）**：选择最长时间没有被引用的页面进行置换，因为如果某些页面长时间未被访问，则它们在将来还可能会长时间不会访问

4. **最不经常使用淘汰算法**：置换访问次数最少的页面

5. **时钟置换算法**：在页表项中增加访问位，描述页面在过去一段时间的内访问情况，将各页面组织成环形链表，指针指向最先调入的页面，访问页面时，在页表项记录页面访问情况，缺页时，从指针处开始顺序查找未被访问的页面进行置换

### 12. 为什么要分堆和栈

1. 栈区（stack） — 由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。栈中的栈帧，随方法的进入和退出有条不紊的进行入栈出栈操作，因此不需要垃圾回收器进行回收。

2. 堆区（heap） — 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事。

3. 全局区（静态区）（static）— 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 程序结束后由系统释放。

4. 文字常量区 — 常量字符串就是放在这里的。程序结束后由系统释放。

5. 程序代码区 — 存放函数体的二进制代码。

### 13. 内存泄漏和内存溢出

- **内存溢出(out of memory)**：程序在为自身申请内存时，没有足够的内存空间供自己使用，出现out of memory；比如你为程序申请了一个integer,但是只给它存了long才能存下的数，就是内存溢出。内存溢出就是你要求被分配的内存超出了系统能给你的内存，系统不能满足你的需求，于是产生溢出。

- **内存泄露(memory leak)**：是指程序在申请内存后，无法释放已经申请到的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存，迟早会被占光。

memory leak会最终会导致out of memory。

### 14. 说说同步和异步，什么时候用同步，什么时候用异步

在任何上下文中，区别无非发起一个操作之后，是什么也不干，直接等待它结束，还是先做别的事，待会儿再查询结果。

**同步**：相当于是排队，前一个人办理完自己的事务，下一个人才能接着办。

**异步**：当发出请求的同时可以做别的事情，需要等待但是又不能阻塞程序的时候需要使用异步

### 15. 如果CPU占用资源很高有可能是什么问题

通常CPU使用率过高常见的有以下几种情况：

1. 木马与病毒

2. 大型游戏或程序

3. 磁盘碎片：有时候经会对电脑的软件安装或者卸载，当文件在安装和卸载的时候，会使硬盘中的数据排列非常分散或者断断续续的，让电脑在查找时速度变慢，就造成大量的使用CPU。

### 16. CPU占用资源低但是系统响应速度很慢可能是什么问题

虚拟内存太大了，把虚拟内存移出系统盘或是系统所在硬盘，并且设置为让系统管理页面文件大小就解决了，而且系统盘的文件碎片也会相对减少。

### 17. 六种进程调度算法

1. **时间片轮转调度算法（RR）**：给每个进程固定的执行时间，根据进程到达的先后顺序让进程在单位时间片内执行，执行完成后便调度下一个进程执行，时间片轮转调度不考虑进程等待时间和执行时间，属于抢占式调度。优点是兼顾长短作业；缺点是平均等待时间较长，上下文切换较费时。

2. **先来先服务调度算法（FCFS）**：根据进程到达的先后顺序执行进程，不考虑等待时间和执行时间，会产生饥饿现象。属于非抢占式调度，优点是公平，实现简单；缺点是不利于短作业。

3. **优先级调度算法（HPF）**：在进程等待队列中选择优先级最高的来执行。

4. **多级反馈队列调度算法**：将时间片轮转与优先级调度相结合，把进程按优先级分成不同的队列，先按优先级调度，优先级相同的，按时间片轮转。优点是兼顾长短作业，有较好的响应时间，可行性强，适用于各种作业环境。

5. **高响应比优先调度算法**：根据“响应比=（进程执行时间+进程等待时间）/ 进程执行时间”这个公式得到的响应比来进行调度。高响应比优先算法在等待时间相同的情况下，作业执行的时间越短，响应比越高，满足段任务优先，同时响应比会随着等待时间增加而变大，优先级会提高，能够避免饥饿现象。优点是兼顾长短作业，缺点是计算响应比开销大，适用于批处理系统。

6. **短作业优先**：选择执行时间最短的进程先执行